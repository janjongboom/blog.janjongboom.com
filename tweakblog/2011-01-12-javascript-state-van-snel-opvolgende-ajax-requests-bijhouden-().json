{
    "title": "Javascript, state van snel opvolgende AJAX requests bijhouden (?)",
    "language": "nl",
    "link": "http://glamour.tweakblogs.net/blog/5932/javascript-state-van-snel-opvolgende-ajax-requests-bijhouden-%28%29.html",
    "date": "2011-01-12T12:53:00.000Z",
    "category": "Frontend",
    "views": 2768,
    "articleHtml": "Tijdens het productiewaardig krijgen van de Javascript van <a href=\"http://glamour.tweakblogs.net/blog/5813/video!-on-the-fly-zoeksuggesties-levenshtein-en-soundex-in-de-praktijk.html\" rel=\"external\">de nieuwe zoeksuggesties</a> stuitte ik op een probleem waarin de gebruiker snel achter elkaar doortypt:<br>\r\n<br>code:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><pre>1\n2\n3\n</pre></td><td class=\"phphighlightcode\"><div><pre>amst            (request #1)\r\namste            (request #2)\r\namster            (request #3)</pre></div></td></tr></table><br>\r\nGeen probleem zolang de requests allemaal even lang duren. Maar wanneer deze terugkomen in de volgorde:<br>\r\n<br>code:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><pre>1\n2\n3\n</pre></td><td class=\"phphighlightcode\"><div><pre>#1\r\n#3\r\n#2</pre></div></td></tr></table><br>\r\nstaat er verkeerde data in de suggesties.<br><a name=\"more\"></a><br>\r\n<b>Oplossingsrichting</b><br>\r\nIn mijn prototype koos ik ervoor om zoiets te implementeren:<br>\r\n<br>JavaScript:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_keyword\">var</span>&#xA0;<span class=\"code_ident\">state</span>&#xA0;=&#xA0;{&#xA0;<span class=\"code_ident\">ajaxRequest</span>:&#xA0;<span class=\"code_keyword\">null</span>&#xA0;};\n<br>\n<br><span class=\"code_keyword\">function</span>&#xA0;<span class=\"code_method\">suggest</span>(<span class=\"code_ident\">query</span>)&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">if</span>(<span class=\"code_ident\">state</span>.<span class=\"code_ident\">ajaxRequest</span>)&#xA0;<span class=\"code_ident\">state</span>.<span class=\"code_ident\">ajaxRequest</span>.<span class=\"code_method\">abort</span>();\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_ident\">state</span>.<span class=\"code_ident\">ajaxRequest</span>=&#xA0;<span class=\"code_ident\">$</span>.<span class=\"code_method\">get</span>(<span class=\"code_string\">&quot;...&quot;</span>,&#xA0;<span class=\"code_keyword\">function</span>(<span class=\"code_ident\">response</span>)&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">if</span>(!<span class=\"code_ident\">response</span>)&#xA0;<span class=\"code_comment\">//&#xA0;aborted;&#xA0;return;</span>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_ident\">state</span>.<span class=\"code_ident\">ajaxRequest</span>=&#xA0;<span class=\"code_keyword\">null</span>;&#xA0;<span class=\"code_comment\">//&#xA0;alleen&#xA0;als&#xA0;succesvol</span>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;});\n<br>}</code></div></td></tr></table><br>\r\nNiet alleen vrij veel code, maar ook het aborten zat me niet helemaal lekker. Nu voor een wat cleanere manier gekozen:<br>\r\n<br>JavaScript:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_keyword\">var</span>&#xA0;<span class=\"code_ident\">state</span>&#xA0;=&#xA0;{&#xA0;<span class=\"code_ident\">requestCounter</span>:&#xA0;<span class=\"code_number\">0</span>&#xA0;};\n<br>\n<br><span class=\"code_keyword\">function</span>&#xA0;<span class=\"code_method\">suggest</span>(<span class=\"code_ident\">query</span>)&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">var</span>&#xA0;<span class=\"code_ident\">requestCounter</span>&#xA0;=&#xA0;++<span class=\"code_ident\">state</span>.<span class=\"code_ident\">requestCounter</span>;\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_ident\">$</span>.<span class=\"code_method\">get</span>(<span class=\"code_string\">&quot;...&quot;</span>,&#xA0;<span class=\"code_keyword\">function</span>&#xA0;(<span class=\"code_ident\">response</span>)&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">if</span>(<span class=\"code_ident\">requestCounter</span>&#xA0;!==&#xA0;<span class=\"code_ident\">state</span>.<span class=\"code_ident\">requestCounter</span>)&#xA0;<span class=\"code_keyword\">return</span>;&#xA0;<span class=\"code_comment\">//&#xA0;is&#xA0;al&#xA0;een&#xA0;nieuwe</span>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;});\n<br>}</code></div></td></tr></table><br>\r\n<br>\r\nWerkt volgens mij net zo goed, of zie ik iets helemaal over het hoofd?",
    "nextLink": "http://glamour.tweakblogs.net/blog/5924/minesweeper-met-javascript-en-canvas.html",
    "comments": [
        {
            "author": "Morax",
            "date": "woensdag 12 januari 2011 13:56",
            "contentHtml": "Je geeft de zoekopdracht toch mee met de query? Kan je dan niet gewoon in de success-functie kijken of het invoerveld nog hetzelfde bevat als wat je in de query meegestuurd hebt? <img src=\"http://tweakimg.net/g/s/smile.gif\" width=\"15\" height=\"15\" alt=\":)\"><p class=\"edit\">[Reactie gewijzigd op woensdag 12 januari 2011 13:56]</p>",
            "ownReply": false
        },
        {
            "author": "swtimmer",
            "date": "woensdag 12 januari 2011 14:08",
            "contentHtml": "Kan je niet pas suggesties gaan geven als je even niet meer typt. Dus als er een x ms geen nieuwe toetsaanslag is pas gaan zoeken? Lijkt me dat je op deze manier gigantisch veel overhead aan het produceren bent.",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "woensdag 12 januari 2011 14:12",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5932/javascript-state-van-snel-opvolgende-ajax-requests-bijhouden-().html#r_79396\">swtimmer schreef op woensdag 12 januari 2011 @ 14:08:</a><br>\r\nKan je niet pas suggesties gaan geven als je even niet meer typt. Dus als er een x ms geen nieuwe toetsaanslag is pas gaan zoeken? Lijkt me dat je op deze manier gigantisch veel overhead aan het produceren bent.</div></blockquote>Ja, maar dat is eigenlijk ook zonde; want we kunnen het qua performance prima aan om live mee te zoeken.<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5932/javascript-state-van-snel-opvolgende-ajax-requests-bijhouden-().html#r_79394\">Morax schreef op woensdag 12 januari 2011 @ 13:56:</a><br>\r\nJe geeft de zoekopdracht toch mee met de query? Kan je dan niet gewoon in de success-functie kijken of het invoerveld nog hetzelfde bevat als wat je in de query meegestuurd hebt? <img src=\"http://tweakimg.net/g/s/smile.gif\" width=\"15\" height=\"15\" alt=\":)\"></div></blockquote>Ja; niet eens zo&apos;n gek idee <img src=\"http://tweakimg.net/g/s/smile.gif\" width=\"15\" height=\"15\" alt=\":)\">",
            "ownReply": true
        },
        {
            "author": "T i M",
            "date": "woensdag 12 januari 2011 15:18",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5932/javascript-state-van-snel-opvolgende-ajax-requests-bijhouden-().html#r_79397\">creator1988 schreef op woensdag 12 januari 2011 @ 14:12:</a><br>\r\n[...]<br>\r\n<br>\r\nJa, maar dat is eigenlijk ook zonde; want we kunnen het qua performance prima aan om live mee te zoeken.<br>\r\n<br>\r\n[...]<br>\r\n<br>\r\nJa; niet eens zo&apos;n gek idee <img src=\"http://tweakimg.net/g/s/smile.gif\" width=\"15\" height=\"15\" alt=\":)\"></div></blockquote>Het is zonde om de bandbreedte te benutten als het niet nodig is.",
            "ownReply": false
        },
        {
            "author": "SPee",
            "date": "woensdag 12 januari 2011 15:21",
            "contentHtml": "<blockquote><div class=\"quote\">maar dat is eigenlijk ook zonde; want we kunnen het qua performance prima aan om live mee te zoeken.</div></blockquote>Misschien wel op de server, maar je hebt ook te maken met de verbinding van je clients.<br>\r\nIk heb op mijn werk al een aantal keer meegemaakt dat Google live search werd uitgeschakeld vanwege de trage verbinding.<br>\r\nEn vele kleine maken....",
            "ownReply": false
        },
        {
            "author": "ReenL",
            "date": "woensdag 12 januari 2011 15:27",
            "contentHtml": "Het probleem met je oplossing is dat wanneer je nu request 2 en 3 uit hebt staan en 2 respond, je de data niet gebruikt om weer te geven. Als vervolgens 3 te lang op zich laat wachten, is het zonde omdat je de data van 2 prima had kunnen gebruiken voor een suggestie.<br>\r\n<br>\r\nMijn voorstel:<br>\r\n<br>code:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n</pre></td><td class=\"phphighlightcode\"><div><pre>var state = { responseId: 0 }; \r\nfunction suggest(query) { \r\n    var requestCounter = ++state.responseId; \r\n    $.get(&quot;...?responseId=&quot;+state.responseId, function (response) { \r\n        if(response.responseId &lt; state.responseId) return; // is al een nieuwe \r\n        state.responseId = response.responseId;\r\n    }); \r\n}</pre></div></td></tr></table><br>\r\n<br>\r\nSucces!<p class=\"edit\">[Reactie gewijzigd op woensdag 12 januari 2011 15:28]</p>",
            "ownReply": false
        },
        {
            "author": "YopY",
            "date": "woensdag 12 januari 2011 15:43",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5932/javascript-state-van-snel-opvolgende-ajax-requests-bijhouden-().html#r_79396\">swtimmer schreef op woensdag 12 januari 2011 @ 14:08:</a><br>\r\nKan je niet pas suggesties gaan geven als je even niet meer typt. Dus als er een x ms geen nieuwe toetsaanslag is pas gaan zoeken? Lijkt me dat je op deze manier gigantisch veel overhead aan het produceren bent.</div></blockquote>Dan zit je al gauw met de ervaring van de gebruiker, want wat is een goeie pauze? 300 ms is bijvoorbeeld genoeg voor de sneller typer (&lt;300 ms tussen twee toetsaanslagen), maar voor de langzame typer die met twee vingers tikt krijg je al gauw een halve seconde tussen toetsaanslagen.<br>\r\n<br>\r\nZelf zou ik - en heb ik ook toegepast - de xmlhttprequests gewoon keihard aborteren met een .abort(). Ik weet niet precies hoe servers met gestopte requests omgaan, maar het lijkt me dat je minder server-resources versplit als je een request gewoon annuleert dan dat je de server uit laat razen en vervolgens niks met het resultaat doet.<br>\r\n<br>\r\nEr zal meer verwerkingstijd zitten tussen het ontvangen, verwerken, in het geheugen plaatsen van een response dan het keihard aborteren en niks geen respons krijgen (aan de client side), lijkt me, theoretisch. immers, je callback methode krijgt altijd een response object terug - dat wordt opgebouwd adhv de server response.<br>\r\n<br>\r\nAls je tot vijfmaal een autosuggest-query uitvoert en die vijf keer negeert, krijg je toch vijf keer dat de server een volledige response terugstuurt en de client tot bij de success-callback dat response verwerkt. Als je abort() aanroept wordt geen van beide gedaan. Misschien dat de server nog wel alle gegevens ophaalt (ik betwijfel of er veel server code geschreven wordt dat goed met tussentijdse abortussen omgaat, bijv. door een lopende SQL query te annuleren (als dat zelfs al mogelijk is).)<br>\r\n<br>\r\nasdfsdfa. Wat ik zelf gedaan heb bij onze autosuggest:<br>\r\n<br>\r\n * Bij een karakterinvoer, zet een timeout aan, staat op dit moment op 300 ms. 300 ms is behoorlijk vlot, maar de chef wil bijna-instant resultaat, dus kan ook niet veel hoger.<br>\r\n * als de gebruiker iets invult, reset de timeout.<br>\r\n * Als de timeout afloopt en de timeout callback uitgevoerd wordt, eerst invoer nakijken. Moet niet leeg zijn, minstens X karakters, en niet gelijk aan de vorige invoer.<br>\r\n * vervolgens AJAX request uitvoeren.<br>\r\n * Als de gebruiker tijdens ajax request (kan tot een seconde duren, is suboptimaal) iets intikt, gelijk huidige request annuleren dmv abort().<br>\r\n * Als request proper afloopt, request afhandelen, gegevens aan gebruiker presenteren, en huidige request op null zetten (dwz er loopt geen request meer).<br>\r\n * rinse &amp; repeat.<br>\r\n<br>\r\nIk ben geen ajax of JS expert, maar logischerwijs lijkt me aborteren beter dan de zwangerschap vervolmaken en vervolgens het resultaat verwaarlozen.<br>\r\n<br>\r\nAJAX requests en zwangerschap. Wie had ooit zo&apos;n link gelegd? <img src=\"http://tweakimg.net/g/s/clown.gif\" width=\"15\" height=\"15\" alt=\":+\"><p class=\"edit\">[Reactie gewijzigd op woensdag 12 januari 2011 15:43]</p>",
            "ownReply": false
        },
        {
            "author": "JohnStaakke",
            "date": "woensdag 12 januari 2011 15:54",
            "contentHtml": "Ik ben het eens met YopY, requests aborten levert meer op imo.",
            "ownReply": false
        },
        {
            "author": "crisp",
            "date": "woensdag 12 januari 2011 22:51",
            "contentHtml": "Ook hier bij Tweakers werken we met een timeout bij karakterinvoer. Daarnaast sturen we nooit meerdere requests simultaan. Als er al een request gedaan is dan wordt er pas een nieuwe request gedaan als deze volledig afgehandeld is en de invoer veranderd is ten opzichte van het voorlaatste request.<br>\r\n<br>\r\nabort() gebruiken we niet aangezien dat geen invloed heeft verder op de serverside verwerking (de request zelf is immers al gedaan) en over het algemeen bij ons de respons dusdanig snel terugkomt dat het weinig zin heeft om requests die nog wachten op respons af te breken. Ik kan me ook herinneren dat sommige browsers in de tijd dat ik onze autosuggest functionaliteit schreef issues hadden met abort().<br>\r\n<br>\r\nIn sommige gevallen, zoals bijvoorbeeld bij suggesties voor plaatsnamen, sturen we al een request bij de eerste letter en halen dan een complete subset op waarbij verdere filtering in javascript zelf gedaan wordt.<br>\r\n<br>\r\nBottomline: probeer in ieder geval ervoor te zorgen dat je het aantal requests zoveel mogelijk minimaliseert. abort() kan handig zijn, maar voorkomen dat je ueberhaupt nutteloze requests stuurt scheelt veel meer, en dat kan je al grotendeels afvangen met een minimale timeout tussen keyinput en het versturen van je request. Het voorkomen van meerdere simultane requests lost je volgorde probleem (ook) op.<br>\r\n<br>\r\nZorg in ieder geval dat je responses snel zijn, en werk indien mogelijk met grotere chunks resultaten die je clientside verder kan filteren. Afhankelijk van de data kan je results natuurlijk ook clientside laten cachen.",
            "ownReply": false
        }
    ]
}