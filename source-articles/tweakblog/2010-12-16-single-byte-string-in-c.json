{
    "title": "Single byte string in C#",
    "language": "nl",
    "link": "http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html",
    "date": "2010-12-16T13:26:00.000Z",
    "category": "Algoritmes",
    "views": 3578,
    "articleHtml": "<b>Definitie van een string</b><br>\r\nIn .NET is een string een verzameling karakters in Unicode. Hierdoor zijn er twee bytes per karakter nodig, plus twee bytes voor het aantal karakters in de string.<br>\r\n<br>C#:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br>2<br>3<br>4<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_comment\">//&#xA0;de&#xA0;string&#xA0;&quot;A&quot;&#xA0;staat&#xA0;in&#xA0;memory&#xA0;als&#xA0;de&#xA0;volgende&#xA0;4&#xA0;bytes:</span>\n<br><span class=\"code_number\">00</span>&#xA0;<span class=\"code_number\">01</span>&#xA0;<span class=\"code_number\">00</span>&#xA0;<span class=\"code_number\">41</span>\n<br><span class=\"code_comment\">//&#xA0;twee&#xA0;bytes&#xA0;met&#xA0;het&#xA0;getal&#xA0;1,&#xA0;voor&#xA0;het&#xA0;aantal&#xA0;elementen&#xA0;(1&#xA0;dus)</span>\n<br><span class=\"code_comment\">//&#xA0;twee&#xA0;bytes&#xA0;met&#xA0;de&#xA0;code&#xA0;voor&#xA0;de&#xA0;letter,&#xA0;in&#xA0;dit&#xA0;geval&#xA0;0x41</span></code></div></td></tr></table><br>\r\nVoordeel hiervan is dat bijna alle karakters in een string kunnen voorkomen. Nadeel is dat wanneer je alleen &apos;eenvoudige&apos; karakters gebruikt (geen fancy tekens als &#xE1; of U+263A) dat je twee keer zoveel geheugen alloceert dan eigenlijk nodig is. Normaal geen enkel probleem.<br>\r\n<br>\r\n<b>Maar als geheugengebruik kritisch is?</b><br>\r\nWanneer je geheugengebruik een belangrijk punt van je applicatie is, en er bovendien veel (en ik bedoel hier v&#xE9;&#xE9;l) strings hebt, dan kan het geheugengebruik een probleem worden. Oplossing is om je strings op te slaan als arrays van &apos;bytes&apos; in plaats van &apos;char&apos;. Een byte heeft namelijk een width van 1 byte (what&apos;s in a name). Je kunt dan alleen wel maximaal 255 verschillende karakters gebruiken in je strings.<br><a name=\"more\"></a><br>\r\n<br>\r\n<b>Implementatie</b><br>\r\nHieronder een simpele implementatie van bovenstaand principe met een voorbeeldimplementatie van &apos;StartsWith&apos; en &apos;Equals&apos;:<br>\r\n<br>C#:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_keyword\">public</span>&#xA0;<span class=\"code_keyword\">static</span>&#xA0;<span class=\"code_keyword\">class</span>&#xA0;<span class=\"code_ident\">StringExtender</span>\n<br>{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">public</span>&#xA0;<span class=\"code_keyword\">static</span>&#xA0;<span class=\"code_keyword\">byte</span>[]&#xA0;<span class=\"code_method\">ToOneWidthByteArray</span>(<span class=\"code_keyword\">this</span>&#xA0;<span class=\"code_keyword\">string</span>&#xA0;<span class=\"code_ident\">s</span>)\n<br>&#xA0;&#xA0;&#xA0;&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">if</span>&#xA0;(<span class=\"code_ident\">s</span>.<span class=\"code_method\">Any</span>(<span class=\"code_ident\">c</span>&#xA0;=&gt;&#xA0;<span class=\"code_ident\">c</span>&#xA0;&gt;&#xA0;<span class=\"code_number\">255</span>))\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">throw</span>&#xA0;<span class=\"code_keyword\">new</span>&#xA0;<span class=\"code_method\">ArgumentException</span>(<span class=\"code_string\">&quot;Chars&#xA0;with&#xA0;an&#xA0;ASCII&#xA0;value&#xA0;of&#xA0;over&#xA0;255&#xA0;are&#xA0;not&#xA0;supported&quot;</span>);\n<br>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">return</span>&#xA0;<span class=\"code_ident\">s</span>.<span class=\"code_method\">Select</span>(<span class=\"code_ident\">ch</span>&#xA0;=&gt;&#xA0;(<span class=\"code_keyword\">byte</span>)<span class=\"code_ident\">ch</span>).<span class=\"code_method\">ToArray</span>();\n<br>&#xA0;&#xA0;&#xA0;&#xA0;}\n<br>}\n<br>\n<br><span class=\"code_keyword\">public</span>&#xA0;<span class=\"code_keyword\">static</span>&#xA0;<span class=\"code_keyword\">class</span>&#xA0;<span class=\"code_ident\">ByteArrayExtender</span>\n<br>{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">public</span>&#xA0;<span class=\"code_keyword\">static</span>&#xA0;<span class=\"code_keyword\">bool</span>&#xA0;<span class=\"code_method\">StartsWith</span>(<span class=\"code_keyword\">this</span>&#xA0;<span class=\"code_keyword\">byte</span>[]&#xA0;<span class=\"code_ident\">b</span>,&#xA0;<span class=\"code_keyword\">string</span>&#xA0;<span class=\"code_ident\">value</span>)\n<br>&#xA0;&#xA0;&#xA0;&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">for</span>&#xA0;(<span class=\"code_keyword\">int</span>&#xA0;<span class=\"code_ident\">i</span>&#xA0;=&#xA0;<span class=\"code_number\">0</span>;&#xA0;<span class=\"code_ident\">i</span>&#xA0;&lt;&#xA0;<span class=\"code_ident\">value</span>.<span class=\"code_ident\">Length</span>;&#xA0;<span class=\"code_ident\">i</span>++)\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">if</span>&#xA0;((<span class=\"code_keyword\">byte</span>)&#xA0;<span class=\"code_ident\">value</span>[<span class=\"code_ident\">i</span>]&#xA0;!=&#xA0;<span class=\"code_ident\">b</span>[<span class=\"code_ident\">i</span>])&#xA0;<span class=\"code_keyword\">return</span>&#xA0;<span class=\"code_keyword\">false</span>;\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">return</span>&#xA0;<span class=\"code_keyword\">true</span>;\n<br>&#xA0;&#xA0;&#xA0;&#xA0;}\n<br>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">public</span>&#xA0;<span class=\"code_keyword\">static</span>&#xA0;<span class=\"code_keyword\">bool</span>&#xA0;<span class=\"code_method\">Equals</span>(<span class=\"code_keyword\">this</span>&#xA0;<span class=\"code_keyword\">byte</span>[]&#xA0;<span class=\"code_ident\">b</span>,&#xA0;<span class=\"code_keyword\">string</span>&#xA0;<span class=\"code_ident\">value</span>)\n<br>&#xA0;&#xA0;&#xA0;&#xA0;{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">if</span>&#xA0;(<span class=\"code_ident\">value</span>.<span class=\"code_ident\">Length</span>&#xA0;!=&#xA0;<span class=\"code_ident\">b</span>.<span class=\"code_ident\">Length</span>)&#xA0;<span class=\"code_keyword\">return</span>&#xA0;<span class=\"code_keyword\">false</span>;\n<br>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">return</span>&#xA0;<span class=\"code_ident\">b</span>.<span class=\"code_method\">StartsWith</span>(<span class=\"code_ident\">value</span>);\n<br>&#xA0;&#xA0;&#xA0;&#xA0;}\n<br>}</code></div></td></tr></table><br>\r\n<br>\r\n<b>Performance</b><br>\r\nOm ook iets zinnigs te kunnen zeggen over de performance hebben we een testje nodig! Even 1.000.000 miljoen strings vergelijken (bovenstaande implementatie van &apos;StartsWith&apos; tegen de native &apos;String.StartsWith&apos;).<br>\r\n<br>C#:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_keyword\">string</span>&#xA0;<span class=\"code_ident\">comparisonString</span>&#xA0;=&#xA0;<span class=\"code_string\">&quot;amsterdam&quot;</span>;\n<br><span class=\"code_keyword\">for</span>&#xA0;(<span class=\"code_keyword\">int</span>&#xA0;<span class=\"code_ident\">i</span>&#xA0;=&#xA0;<span class=\"code_number\">0</span>;&#xA0;<span class=\"code_ident\">i</span>&#xA0;&lt;&#xA0;<span class=\"code_number\">1000000</span>;&#xA0;<span class=\"code_ident\">i</span>++)\n<br>{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_comment\">//&#xA0;doe&#xA0;een&#xA0;Ordinal&#xA0;startsWith&#xA0;(snelste)</span>\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">bool</span>&#xA0;<span class=\"code_ident\">x</span>&#xA0;=&#xA0;<span class=\"code_ident\">comparisonString</span>.<span class=\"code_method\">StartsWith</span>(<span class=\"code_string\">&quot;a&quot;</span>,&#xA0;<span class=\"code_ident\">StringComparison</span>.<span class=\"code_ident\">Ordinal</span>);\n<br>}\n<br><span class=\"code_comment\">//&#xA0;String.StartsWith&#xA0;took&#xA0;42,15&#xA0;ms.</span>\n<br>\n<br><span class=\"code_comment\">//&#xA0;Let&#xA0;op!&#xA0;Deze&#xA0;methode&#xA0;wordt&#xA0;ook&#xA0;meegenomen&#xA0;in&#xA0;de&#xA0;timing.</span>\n<br><span class=\"code_keyword\">byte</span>[]&#xA0;<span class=\"code_ident\">comparisonByteArray</span>&#xA0;=&#xA0;<span class=\"code_string\">&quot;amsterdam&quot;</span>.<span class=\"code_method\">ToOneWidthByteArray</span>();\n<br><span class=\"code_keyword\">for</span>&#xA0;(<span class=\"code_keyword\">int</span>&#xA0;<span class=\"code_ident\">i</span>&#xA0;=&#xA0;<span class=\"code_number\">0</span>;&#xA0;<span class=\"code_ident\">i</span>&#xA0;&lt;&#xA0;<span class=\"code_number\">1000000</span>;&#xA0;<span class=\"code_ident\">i</span>++)\n<br>{\n<br>&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"code_keyword\">bool</span>&#xA0;<span class=\"code_ident\">y</span>&#xA0;=&#xA0;<span class=\"code_ident\">comparisonByteArray</span>.<span class=\"code_method\">StartsWith</span>(<span class=\"code_string\">&quot;a&quot;</span>);\n<br>}\n<br><span class=\"code_comment\">//&#xA0;Byte[].StartsWidth&#xA0;took&#xA0;51,75&#xA0;ms.</span></code></div></td></tr></table><br>\r\n<br>\r\n<b>Dus?</b><br>\r\nPerformance is wat minder, maar het geheugengebruik scheelt aanzienlijk (in onze case van 300 MB -&gt; 190 MB). De performance-loss is weliswaar +20% maar in de praktijk niet merkbaar. Mocht je dus ooit tegen dit probleem aanlopen; het k&#xE1;n een oplossing zijn maar wel met een prijs.",
    "nextLink": "http://glamour.tweakblogs.net/blog/5747/expression-trees-espresso-voor-je-code%21.html",
    "comments": [
        {
            "author": "[ti]",
            "date": "donderdag 16 december 2010 14:42",
            "contentHtml": "Wat ik eigenlijk interessanter vind om te weten: waar had je &apos;t nou voor nodig?",
            "ownReply": false
        },
        {
            "author": "StM",
            "date": "donderdag 16 december 2010 14:46",
            "contentHtml": "Zou je hem niet veel sneller moeten kunnen maken dmv unsafe code en het niet gebruiken van LINQ? Volgens mij komt een deel van je performance loss door je implementatie.",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "donderdag 16 december 2010 14:47",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77275\">[ti] schreef op donderdag 16 december 2010 @ 14:42:</a><br>\r\nWat ik eigenlijk interessanter vind om te weten: waar had je &apos;t nou voor nodig?</div></blockquote>Bezig met een nieuw zoeksysteem voor funda, waar je op alle geografische entiteiten kunt zoeken (dus bv. &apos;de pijp in amsterdam&apos;); en we hebben alles in verschillende formaten in memory staan om elke zoekopdracht in 5 ms. te vertalen naar een set met suggesties. 600 MB (waarvan 300 aan alleen maar strings) per server om zoiets te serveren is nogal veel.<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77277\">StM schreef op donderdag 16 december 2010 @ 14:46:</a><br>\r\nZou je hem niet veel sneller moeten kunnen maken dmv unsafe code en het niet gebruiken van LINQ? Volgens mij komt een deel van je performance loss door je implementatie.</div></blockquote>Mweh, normaal gesproken wel maar LINQ wordt hier alleen gebruikt om de string om te zetten naar bytes, en die operatie is echt fracties van een milliseconde. Unsafe arrays vergelijken gaat waarschijnlijk wel sneller, maar de performance is niet zo slecht dat het nodig is om om dat level te gaan optimaliseren.<p class=\"edit\">[Reactie gewijzigd op donderdag 16 december 2010 14:49]</p>",
            "ownReply": true
        },
        {
            "author": "Ventieldopje",
            "date": "donderdag 16 december 2010 14:58",
            "contentHtml": "Ik vind 20% nogal wat, juist vooral als je veel strings gebruikt dan heb ik persoonlijk liever dat hij iets meer geheugen gebruik (wordt blijkbaar toch nuttig gebruikt) en sneller is <img src=\"http://tweakimg.net/g/s/wink.gif\" width=\"15\" height=\"15\" alt=\";)\"><br>\r\n<br>\r\nMaar wel leuk gevonden <img src=\"http://tweakimg.net/g/s/wink.gif\" width=\"15\" height=\"15\" alt=\";)\">",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "donderdag 16 december 2010 15:05",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77280\">Phas0r schreef op donderdag 16 december 2010 @ 14:58:</a><br>\r\nIk vind 20% nogal wat, juist vooral als je veel strings gebruikt dan heb ik persoonlijk liever dat hij iets meer geheugen gebruik (wordt blijkbaar toch nuttig gebruikt) en sneller is <img src=\"http://tweakimg.net/g/s/wink.gif\" width=\"15\" height=\"15\" alt=\";)\"><br>\r\n<br>\r\nMaar wel leuk gevonden <img src=\"http://tweakimg.net/g/s/wink.gif\" width=\"15\" height=\"15\" alt=\";)\"></div></blockquote>Nou, volgens mij is de truc bij zulke grote sets om zo min mogelijk string comparisons te doen. We gebruiken in principe in-memory lookup tables met daarin per 2 karakters een linked list met alle entiteiten:<br>\r\n<br>code:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><pre>1\n</pre></td><td class=\"phphighlightcode\"><div><pre>lookup[&quot;am&quot;] -&gt; contains Amsterdam, Amstelveen etc.</pre></div></td></tr></table><br>\r\nDaardoor kan je 99,5% van al je potenti&#xEB;le matches al weggooien. Daarna doen we een startsWith, en die hit is voor ons vrij goedkoop (de calls worden niet ineens allemaal 20% trager dus).<br>\r\n<br>C#:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_ident\">lookup</span>[<span class=\"code_string\">&quot;am&quot;</span>].<span class=\"code_method\">Where</span>(<span class=\"code_ident\">a</span>=&gt;<span class=\"code_ident\">a</span>.<span class=\"code_ident\">Key</span>.<span class=\"code_method\">StartsWith</span>(<span class=\"code_string\">&quot;amster&quot;</span>));&#xA0;<span class=\"code_comment\">//&#xA0;zoiets</span></code></div></td></tr></table><p class=\"edit\">[Reactie gewijzigd op donderdag 16 december 2010 15:05]</p>",
            "ownReply": true
        },
        {
            "author": "BeerenburgCola",
            "date": "donderdag 16 december 2010 15:13",
            "contentHtml": "Heb je ook al aan utf-8 gedacht ? <br>\r\n<br>\r\nKun je wel alle tekens in opslaan en scheelt gemiddeld toch bijna 50% aan ruimte. <br>\r\n(ASCII karakters &lt; 128 nemen by design nog steeds &#xE9;&#xE9;n byte in beslag in utf-8)  <br>\r\n<br>\r\nJe string compares kan je dan ook nog steeds op byte niveau doen. <br>\r\nEr zijn vast wel bibliotheken voor in C#.",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "donderdag 16 december 2010 15:23",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77283\">BeerenburgCola schreef op donderdag 16 december 2010 @ 15:13:</a><br>\r\nHeb je ook al aan utf-8 gedacht ? <br>\r\n<br>\r\nKun je wel alle tekens in opslaan en scheelt gemiddeld toch bijna 50% aan ruimte. <br>\r\n(ASCII karakters &lt; 128 nemen by design nog steeds &#xE9;&#xE9;n byte in beslag in utf-8)  <br>\r\n<br>\r\nJe string compares kan je dan ook nog steeds op byte niveau doen. <br>\r\nEr zijn vast wel bibliotheken voor in C#.</div></blockquote>Dat is dan alleen bruikbaar voor het omzetten van String -&gt; Byte Array. Voor zover ik kan vinden zijn er geen string implementaties op basis van UTF8 voor .NET. Maar nee, niet aan gedacht; wel een nuttige toevoeging.",
            "ownReply": true
        },
        {
            "author": "PoweRoy",
            "date": "donderdag 16 december 2010 15:31",
            "contentHtml": "<blockquote><div class=\"quote\">Een byte heeft namelijk een width van 1 byte (what&apos;s in a name). Je kunt dan alleen wel maximaal 255 verschillende karakters gebruiken in je strings.</div></blockquote>Dit gaat erg leuk worden als je dus wel exotische characters gaat gebruiken. Theoretisch kan je 255 verschillende characters alleen zijn de eerste 128 ASCII (de basis) goed te gebruiken alleen de laatste 128 (extended ASCII) beschreven in Code Pages. Dus leuk als je dit consequent dit alleen in Nederland doet (bv Code Page Windows-1252) maar in het buitenland wordt dit een feest. (een character heeft dan meerdere betekenissen)<br>\r\n<br>\r\nBij unicode is dit niet omdat alle soort characters een unieke waarde  hebben.<br>\r\n<br>\r\nKortom dit soort optimalisaties gaan iets te ver. Geheugen is niet echt kritisch zou ik zeggen, je kan er altijd extra geheugen bij zetten <img src=\"http://tweakimg.net/g/s/vork.gif\" width=\"20\" height=\"15\" alt=\":Y)\"> <br>\r\n<br>\r\n@creator1988 heeft bevoorbeeld een heel handige performance increase door gewoon goed om te gaan met resources <img src=\"http://tweakimg.net/g/s/smile.gif\" width=\"15\" height=\"15\" alt=\":)\">",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "donderdag 16 december 2010 15:36",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77286\">PoweRoy schreef op donderdag 16 december 2010 @ 15:31:</a><br>\r\nDit gaat erg leuk worden als je dus wel exotische characters gaat gebruiken. Theoretisch kan je 255 verschillende characters alleen zijn de eerste 128 ASCII (de basis) goed te gebruiken alleen de laatste 128 (extended ASCII) beschreven in Code Pages. Dus leuk als je dit consequent dit alleen in Nederland doet (bv Code Page Windows-1252) maar in het buitenland wordt dit een feest. (een character heeft dan meerdere betekenissen)</div></blockquote>Klopt als een bus. In [link=http://glamour.tweakblogs.net/blog/5732/diakritische-tekens-en-soundex-in-net.html]dit artikel[/link] heb ik wat code staan om dat soort data eruit te halen. Ik gebruik dit daarom ook alleen voor genormaliseerde velden die alleen ASCII chars &lt; 127 bevatten. Sowieso kan je je eigen extended ascii set defini&#xEB;ren als je het wel nodig hebt (als we dan toch aan micro-optimaliseren zijn). Terug naar de DOS tijd zeg maar  <img src=\"http://tweakimg.net/g/s/smile.gif\" width=\"15\" height=\"15\" alt=\":)\"> .<blockquote><div class=\"quote\">Kortom dit soort optimalisaties gaan iets te ver. Geheugen is niet echt kritisch zou ik zeggen, je kan er altijd extra geheugen bij zetten <img src=\"http://tweakimg.net/g/s/vork.gif\" width=\"20\" height=\"15\" alt=\":Y)\"></div></blockquote>Niet waar. Wij hebben nog een aantal webservers die gewoon 32-bits zijn, daar is geheugen wel degelijk een issue. In dit soort gevallen kan het kosteneffici&#xEB;nter zijn om je geheugengebruik gewoon goed in de gaten te houden.",
            "ownReply": true
        },
        {
            "author": "FlowinG",
            "date": "donderdag 16 december 2010 16:06",
            "contentHtml": "Linq is over het algemeen duur, het bespaart misschien geheugen maar kost meer processorkracht. Ik weet niet hoe dit precies verhoud met het Select statement. Maar waarom niet het volgende: <br>\r\n<br>\r\n<br>C#:<br><table class=\"phphighlight\"><tr><td class=\"phphighlightline\"><code>1<br></code></td><td class=\"phphighlightcode\"><div><code><span class=\"code_keyword\">byte</span>[]&#xA0;<span class=\"code_ident\">bytes</span>&#xA0;=&#xA0;<span class=\"code_ident\">System</span>.<span class=\"code_ident\">Text</span>.<span class=\"code_ident\">Encoding</span>.<span class=\"code_ident\">UTF8</span>.<span class=\"code_method\">GetBytes</span>(<span class=\"code_string\">&quot;bladiebla&quot;</span>);</code></div></td></tr></table><br>\r\n<br>\r\nUTF8 is standaard 1 byte tenzij je vreemde karakters hebt.<p class=\"edit\">[Reactie gewijzigd op donderdag 16 december 2010 16:10]</p>",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "donderdag 16 december 2010 17:00",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77292\">FlowinG schreef op donderdag 16 december 2010 @ 16:06:</a><br>\r\nLinq is over het algemeen duur, het bespaart misschien geheugen maar kost meer processorkracht. Ik weet niet hoe dit precies verhoud met het Select statement. Maar waarom niet het volgende:</div></blockquote>Klopt niet helemaal; als je weet hoe LINQ vertaalt is het net zo snel als het uitschrijven. <br>\r\n<br>\r\nAnyhow: ja UTF8.GetBytes is significant sneller dan mijn implementatie; had mezelf dat even niet gerealiseerd. Desondanks heeft het niet zo heel veel effect. Het vertalen van string -&gt; bytearray kost relatief gezien namelijk niet zoveel. De vergelijkingen zijn veel duurder.",
            "ownReply": true
        },
        {
            "author": "H!GHGuY",
            "date": "donderdag 16 december 2010 18:55",
            "contentHtml": "Er zijn ook nog wel efficientere string compares te vinden... <br>\r\nAfhankelijk van de datasets en de operaties kan een radix tree/patricia tree ook aangeraden zijn.",
            "ownReply": false
        },
        {
            "author": "donderdag 16 december 2010 21:54",
            "date": "",
            "contentHtml": "Zeg, creator1988. Aan je manier van schrijven denk ik dat je religieus bent.<br>\r\n<br>\r\nKlopt dat?<br>\r\n<br>\r\nVr Gr,",
            "ownReply": false
        },
        {
            "author": "creator1988",
            "date": "vrijdag 17 december 2010 01:38",
            "contentHtml": "<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77312\">H!GHGuY schreef op donderdag 16 december 2010 @ 18:55:</a><br>\r\nEr zijn ook nog wel efficientere string compares te vinden... <br>\r\nAfhankelijk van de datasets en de operaties kan een radix tree/patricia tree ook aangeraden zijn.</div></blockquote>Ja, effici&#xEB;nter geloof ik wel, maar volgens mij is elke tree based methode sowieso minder effici&#xEB;nt qua geheugengebruik, waar het hier dan weer more or less om ging. Sowieso doen we al ongeveer hetzelfde als in dit soort methodes door een lookuptable op de eerste twee chars te maken.<blockquote><div class=\"quote\"><a href=\"http://glamour.tweakblogs.net/blog/5759/single-byte-string-in-c.html#r_77316\">Boon schreef op donderdag 16 december 2010 @ 21:54:</a><br>\r\nZeg, creator1988. Aan je manier van schrijven denk ik dat je religieus bent.<br>\r\n<br>\r\nKlopt dat?</div></blockquote>Uh lol whut? En nee.",
            "ownReply": true
        }
    ]
}